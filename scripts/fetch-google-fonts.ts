/**
 * Build Script: Fetch Google Fonts Metadata
 *
 * Fetches Google Fonts and generates a TypeScript file with font metadata.
 * Uses direct TTF URLs from the Google Fonts API (required by shotstack-canvas).
 *
 * Usage:
 *   GOOGLE_FONTS_API_KEY=xxx npx tsx scripts/fetch-google-fonts.ts
 *
 * Get an API key from: https://developers.google.com/fonts/docs/developer_api
 */

import { writeFileSync } from "fs";
import { resolve, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));

const API_KEY = process.env.GOOGLE_FONTS_API_KEY;
const GOOGLE_FONTS_API = "https://www.googleapis.com/webfonts/v1/webfonts";
const OUTPUT_PATH = resolve(__dirname, "../src/core/fonts/google-fonts.ts");

/** Icon/symbol fonts that don't render as text - exclude from the bundle */
const EXCLUDED_FONTS = new Set([
	"Material Icons",
	"Material Symbols",
	"Material Symbols Outlined",
	"Material Symbols Rounded",
	"Material Symbols Sharp",
	"Noto Color Emoji",
	"Noto Emoji"
]);

interface GoogleFontsApiItem {
	family: string;
	variants: string[];
	subsets: string[];
	category: string;
	files: Record<string, string>; // variant -> TTF URL (e.g., "regular" -> "https://fonts.gstatic.com/s/.../file.ttf")
}

interface GoogleFontsApiResponse {
	items: GoogleFontsApiItem[];
}

interface GoogleFont {
	displayName: string;
	filename: string;
	category: string;
	url: string;
	weight: number;
}

/**
 * Extract filename from gstatic URL
 * e.g., https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTcviYwYZ8UA3.ttf
 *       â†’ UcCO3FwrK3iLTcviYwYZ8UA3
 */
function extractFilename(url: string): string {
	const match = url.match(/\/([^/]+)\.ttf$/);
	return match ? match[1] : "";
}

/**
 * Get the best URL for regular (400) weight from the files object
 */
function getRegularUrl(files: Record<string, string>): string | null {
	// Try these keys in order of preference
	const keys = ["regular", "400", "300", "500"];
	for (const key of keys) {
		if (files[key]) {
			return files[key];
		}
	}
	// Fall back to first available
	const firstKey = Object.keys(files)[0];
	return firstKey ? files[firstKey] : null;
}

/**
 * Get the weight value from a variant key
 */
function getWeightFromVariant(variant: string): number {
	if (variant === "regular" || variant === "italic") return 400;
	const num = parseInt(variant, 10);
	return isNaN(num) ? 400 : num;
}

async function main() {
	if (!API_KEY) {
		console.error("Error: GOOGLE_FONTS_API_KEY environment variable is required");
		console.error("Get an API key from: https://developers.google.com/fonts/docs/developer_api");
		process.exit(1);
	}

	console.log("Fetching Google Fonts API...");
	const response = await fetch(`${GOOGLE_FONTS_API}?key=${API_KEY}&sort=popularity`);

	if (!response.ok) {
		console.error(`API request failed: ${response.status} ${response.statusText}`);
		process.exit(1);
	}

	const data = (await response.json()) as GoogleFontsApiResponse;
	console.log(`Found ${data.items.length} fonts from API`);

	const fonts: GoogleFont[] = [];
	let skipped = 0;

	for (const item of data.items) {
		// Skip icon/symbol fonts that don't render as text
		if (EXCLUDED_FONTS.has(item.family)) {
			skipped++;
			continue;
		}

		// Get the regular weight URL (the API returns direct TTF URLs)
		const url = getRegularUrl(item.files);
		if (!url) {
			skipped++;
			continue;
		}

		// Ensure it's a TTF URL
		if (!url.endsWith(".ttf")) {
			skipped++;
			continue;
		}

		const filename = extractFilename(url);
		if (!filename) {
			skipped++;
			continue;
		}

		// Determine weight from the variant we got
		const variantKey = Object.keys(item.files).find((k) => item.files[k] === url) ?? "regular";
		const weight = getWeightFromVariant(variantKey);

		fonts.push({
			displayName: item.family,
			filename,
			category: item.category,
			url,
			weight
		});
	}

	console.log(`Successfully processed ${fonts.length} fonts (${skipped} skipped)`);

	// Generate TypeScript file
	const output = `/**
 * Google Fonts Metadata
 *
 * Auto-generated by scripts/fetch-google-fonts.ts
 * DO NOT EDIT MANUALLY
 *
 * Contains ${fonts.length} fonts from Google Fonts, sorted by popularity.
 * Generated: ${new Date().toISOString()}
 */

export interface GoogleFont {
	/** Human-readable font name (e.g., "Inter") */
	displayName: string;
	/** Filename hash from gstatic URL - stored in asset.font.family */
	filename: string;
	/** Font category for filtering */
	category: "sans-serif" | "serif" | "display" | "handwriting" | "monospace";
	/** Full gstatic URL (TTF format) - stored in timeline.fonts */
	url: string;
	/** Primary weight for this font file */
	weight: number;
}

export const GOOGLE_FONTS: GoogleFont[] = ${JSON.stringify(fonts, null, "\t")};

/** Map from filename to font for reverse lookup */
export const GOOGLE_FONTS_BY_FILENAME = new Map<string, GoogleFont>(
	GOOGLE_FONTS.map((font) => [font.filename, font])
);

/** Map from display name to font */
export const GOOGLE_FONTS_BY_NAME = new Map<string, GoogleFont>(
	GOOGLE_FONTS.map((font) => [font.displayName, font])
);

/** Font categories */
export const GOOGLE_FONT_CATEGORIES = ["sans-serif", "serif", "display", "handwriting", "monospace"] as const;
export type GoogleFontCategory = (typeof GOOGLE_FONT_CATEGORIES)[number];
`;

	writeFileSync(OUTPUT_PATH, output, "utf-8");
	console.log(`\nGenerated: ${OUTPUT_PATH}`);
	console.log(`File size: ${(output.length / 1024).toFixed(1)} KB`);
}

main().catch(console.error);
